package no.sikt.nva.approvals.persistence;

import static no.sikt.nva.approvals.persistence.DynamoDbConstants.GSI1;
import static no.sikt.nva.approvals.persistence.DynamoDbConstants.GSI2;
import static no.sikt.nva.approvals.persistence.DynamoDbConstants.PK0;
import static no.sikt.nva.approvals.persistence.DynamoDbConstants.PK1;
import static no.sikt.nva.approvals.persistence.DynamoDbConstants.PK2;
import static no.sikt.nva.approvals.persistence.DynamoDbConstants.SK0;
import static no.sikt.nva.approvals.persistence.DynamoDbConstants.SK1;
import static no.sikt.nva.approvals.persistence.DynamoDbConstants.SK2;
import static no.sikt.nva.approvals.persistence.DynamoDbLocal.dynamoDBLocal;
import static software.amazon.awssdk.enhanced.dynamodb.AttributeValueType.S;
import static software.amazon.awssdk.enhanced.dynamodb.TableMetadata.primaryIndexName;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.primaryPartitionKey;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.primarySortKey;

import java.time.Instant;
import nva.commons.core.Environment;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import software.amazon.awssdk.enhanced.dynamodb.AttributeConverterProvider;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbTable;
import software.amazon.awssdk.enhanced.dynamodb.TableSchema;
import software.amazon.awssdk.enhanced.dynamodb.document.DocumentTableSchema;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AtomicCounterExtension;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedTimestampRecordExtension;
import software.amazon.awssdk.enhanced.dynamodb.extensions.VersionedRecordExtension;
import software.amazon.awssdk.enhanced.dynamodb.mapper.StaticImmutableTableSchema;

public class ExampleTest {
  private static final Environment ENVIRONMENT = new Environment();
  private static final String TABLE = ENVIRONMENT.readEnv(DynamoDbConstants.TABLE);
  private DynamoDbLocal dynamoDbLocal;

  @BeforeEach
  void setUp() {
    dynamoDbLocal = dynamoDBLocal(TABLE);
  }

  private static DocumentTableSchema documentTableSchema() {
    return TableSchema.documentSchemaBuilder()
      .addIndexPartitionKey(primaryIndexName(), PK0, S)
      .addIndexSortKey(primaryIndexName(), SK0, S)
      .addIndexPartitionKey(GSI1, PK1, S)
      .addIndexSortKey(GSI1, SK1, S)
      .addIndexPartitionKey(GSI2, PK2, S)
      .addIndexSortKey(GSI2, SK2, S)
      .attributeConverterProviders(AttributeConverterProvider.defaultProvider())
      .build();
  }

  @Test
  public void testWithRecord() {
    var enhancedClient =
        DynamoDbEnhancedClient.builder()
            .dynamoDbClient(dynamoDbLocal.client())
            .extensions(
                AutoGeneratedTimestampRecordExtension.create(),
                AtomicCounterExtension.builder().build(),
                VersionedRecordExtension.builder().build())
            .build();
    var repository = new ApprovalRepositoryV2(enhancedClient, TABLE);
//    DynamoDbTable<OrderRecord> orderTable = enhancedClient.table(TABLE, ORDER_RECORD_SCHEMA);
//    DynamoDbTable<OrderRecord> orderTable = enhancedClient.table(TABLE, documentTableSchema());

    // Create a new order
    var initialInsert = new OrderRecord("123", "order-abc", "PENDING", Instant.now(), null);
    orderTable.putItem(initialInsert);
    System.out.println("initialInsert: " + initialInsert); // version will be 1

    // Read it back
    var key = OrderRecord.from("123", "order-abc");
    var firstRead = orderTable.getItem(key);
    System.out.println("firstRead: " + firstRead);

    // Update it - version gets incremented automatically
    var firstPutRecord = firstRead.copy().status("SHIPPED").build();
    System.out.println("firstPutRecord: " + firstPutRecord); // version will be 2
    orderTable.putItem(firstPutRecord);
    var secondRead = orderTable.getItem(key);
    System.out.println("secondRead: " + secondRead);

    var thirdRead = orderTable.getItem(key);
    System.out.println("thirdRead: " + thirdRead);

    // Simulate a conflict - try to update with stale version
    var staleOrder = firstRead.copy().status("CANCELLED").build();

    try {
      orderTable.putItem(staleOrder);
    } catch (Exception e) {
      System.out.println("Conflict detected: " + e.getClass().getSimpleName());
    }
  }
}
